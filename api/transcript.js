/**
 * YouTube 자막 추출 API
 * Innertube API + JSON3 형식 사용
 */

const INNERTUBE_API_URL = 'https://www.youtube.com/youtubei/v1/player';
const DEFAULT_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';

// ANDROID 클라이언트 사용 (Vercel에서도 잘 작동)
const INNERTUBE_CONTEXT = {
    client: {
        clientName: 'ANDROID',
        clientVersion: '19.09.37',
        androidSdkVersion: 30,
        hl: 'ko',
        gl: 'KR',
    }
};

export default async function handler(req, res) {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    const { videoId, lang = 'ko' } = req.query;

    if (!videoId) {
        return res.status(400).json({ error: 'videoId is required' });
    }

    if (!/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
        return res.status(400).json({ error: 'Invalid video ID format' });
    }

    try {
        const transcript = await fetchTranscript(videoId, lang);
        return res.status(200).json(transcript);
    } catch (error) {
        console.error('Transcript error:', error.message);
        return res.status(500).json({
            error: error.message || '자막을 가져올 수 없습니다.',
            videoId,
        });
    }
}

async function fetchTranscript(videoId, preferredLang) {
    // Step 1: Innertube API 호출
    const apiUrl = `${INNERTUBE_API_URL}?key=${DEFAULT_API_KEY}`;

    const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            context: INNERTUBE_CONTEXT,
            videoId: videoId,
        }),
    });

    if (!response.ok) {
        throw new Error('YouTube API 요청 실패');
    }

    const data = await response.json();

    // Playability 확인
    const status = data.playabilityStatus?.status;
    const reason = data.playabilityStatus?.reason;

    if (status === 'LOGIN_REQUIRED') {
        if (reason && (reason.includes('bot') || reason.includes('Sign in'))) {
            throw new Error('YouTube가 봇을 감지했습니다. 잠시 후 다시 시도해주세요.');
        }
        throw new Error(reason || '로그인이 필요합니다.');
    }

    if (status !== 'OK') {
        throw new Error(reason || '영상을 재생할 수 없습니다.');
    }

    // 자막 트랙 확인
    const captionsRenderer = data.captions?.playerCaptionsTracklistRenderer;
    if (!captionsRenderer) {
        throw new Error('이 영상에는 자막이 비활성화되어 있습니다.');
    }

    const captionTracks = captionsRenderer.captionTracks || [];
    if (captionTracks.length === 0) {
        throw new Error('이 영상에는 사용 가능한 자막이 없습니다.');
    }

    // Step 2: 자막 트랙 선택 (우선순위에 따라)
    const targetTrack = selectTrack(captionTracks, preferredLang);

    // Step 3: 자막 데이터 가져오기 (JSON3 형식)
    let transcriptUrl = targetTrack.baseUrl;
    transcriptUrl = transcriptUrl.replace('&fmt=srv3', '&fmt=json3');

    // fmt 파라미터가 없으면 추가
    if (!transcriptUrl.includes('fmt=')) {
        transcriptUrl += '&fmt=json3';
    }

    const transcriptResponse = await fetch(transcriptUrl);

    if (!transcriptResponse.ok) {
        throw new Error('자막 데이터를 가져올 수 없습니다.');
    }

    const transcriptText = await transcriptResponse.text();

    // Step 4: 파싱
    let segments;
    try {
        // JSON3 형식 파싱
        const json = JSON.parse(transcriptText);
        segments = parseJson3(json);
    } catch (e) {
        // XML 형식 폴백
        segments = parseSrv3Xml(transcriptText);
    }

    if (segments.length === 0) {
        throw new Error('자막 내용을 파싱할 수 없습니다.');
    }

    const fullText = segments.map(s => s.text).join(' ');

    // 언어 이름 추출
    let languageName = targetTrack.languageCode;
    if (targetTrack.name) {
        if (targetTrack.name.runs && targetTrack.name.runs[0]) {
            languageName = targetTrack.name.runs[0].text;
        } else if (targetTrack.name.simpleText) {
            languageName = targetTrack.name.simpleText;
        }
    }

    return {
        videoId,
        language: targetTrack.languageCode || preferredLang,
        languageName,
        segments,
        fullText,
        segmentCount: segments.length,
        isAutoGenerated: targetTrack.kind === 'asr',
    };
}

/**
 * 우선순위에 따라 자막 트랙 선택
 */
function selectTrack(tracks, preferredLang) {
    const manualTracks = tracks.filter(t => t.kind !== 'asr');
    const generatedTracks = tracks.filter(t => t.kind === 'asr');

    const findTrack = (list, lang) => list.find(t => t.languageCode === lang);

    // 우선순위: 수동(선호) > 자동(선호) > 수동(ko) > 자동(ko) > 수동(en) > 자동(en) > 첫번째
    let target = findTrack(manualTracks, preferredLang);
    if (!target) target = findTrack(generatedTracks, preferredLang);
    if (!target) target = findTrack(manualTracks, 'ko');
    if (!target) target = findTrack(generatedTracks, 'ko');
    if (!target) target = findTrack(manualTracks, 'en');
    if (!target) target = findTrack(generatedTracks, 'en');
    if (!target) target = tracks[0];

    if (!target || !target.baseUrl) {
        throw new Error('자막 URL을 찾을 수 없습니다.');
    }

    return target;
}

/**
 * JSON3 형식 파싱
 */
function parseJson3(json) {
    const segments = [];

    if (!json.events) {
        return segments;
    }

    for (const event of json.events) {
        if (event.segs) {
            const text = event.segs.map(s => s.utf8 || '').join('').trim();
            if (text) {
                segments.push({
                    start: (event.tStartMs || 0) / 1000,
                    duration: (event.dDurationMs || 0) / 1000,
                    text,
                });
            }
        }
    }

    return segments;
}

/**
 * srv3 XML 형식 파싱
 */
function parseSrv3Xml(xmlText) {
    const segments = [];

    // <p t="시작ms" d="지속ms">...</p> 형식
    const pTagRegex = /<p\s+t="(\d+)"(?:\s+d="(\d+)")?[^>]*>([\s\S]*?)<\/p>/g;
    let match;

    while ((match = pTagRegex.exec(xmlText)) !== null) {
        const startMs = parseInt(match[1]);
        const durationMs = parseInt(match[2] || '0');
        const content = match[3];

        // <s> 태그 안의 텍스트 추출
        let text = '';
        const sTagRegex = /<s[^>]*>([^<]*)<\/s>/g;
        let sMatch;
        while ((sMatch = sTagRegex.exec(content)) !== null) {
            text += sMatch[1];
        }

        // <s> 태그가 없으면 전체 내용
        if (!text) {
            text = content.replace(/<[^>]*>/g, '');
        }

        text = decodeHtmlEntities(text.trim());
        if (text) {
            segments.push({
                start: startMs / 1000,
                duration: durationMs / 1000,
                text,
            });
        }
    }

    // 레거시 <text> 형식 폴백
    if (segments.length === 0) {
        const textRegex = /<text\s+start="([^"]+)"(?:\s+dur="([^"]+)")?[^>]*>([\s\S]*?)<\/text>/g;
        while ((match = textRegex.exec(xmlText)) !== null) {
            const start = parseFloat(match[1]);
            const duration = parseFloat(match[2] || '0');
            let text = match[3].replace(/<[^>]*>/g, '');
            text = decodeHtmlEntities(text.trim());
            if (text) {
                segments.push({ start, duration, text });
            }
        }
    }

    return segments;
}

function decodeHtmlEntities(text) {
    if (!text) return '';

    return text
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&apos;/g, "'")
        .replace(/&#(\d+);/g, (_, num) => String.fromCharCode(parseInt(num, 10)))
        .replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
        .replace(/\n/g, ' ');
}
