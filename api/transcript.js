/**
 * YouTube 자막 추출 API
 * Vercel Edge Function
 */

export const config = {
    runtime: 'edge',
};

export default async function handler(request) {
    const url = new URL(request.url);
    const videoId = url.searchParams.get('videoId');
    const lang = url.searchParams.get('lang') || 'ko';

    if (!videoId) {
        return new Response(JSON.stringify({ error: 'videoId is required' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json' },
        });
    }

    try {
        // YouTube 영상 페이지에서 자막 데이터 추출
        const transcript = await fetchYouTubeTranscript(videoId, lang);

        return new Response(JSON.stringify(transcript), {
            status: 200,
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
            },
        });
    } catch (error) {
        console.error('Transcript fetch error:', error);
        return new Response(JSON.stringify({
            error: error.message || 'Failed to fetch transcript',
            videoId,
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
        });
    }
}

async function fetchYouTubeTranscript(videoId, lang) {
    // YouTube 영상 페이지 가져오기
    const videoPageResponse = await fetch(`https://www.youtube.com/watch?v=${videoId}`, {
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
        },
    });

    if (!videoPageResponse.ok) {
        throw new Error('Failed to fetch video page');
    }

    const html = await videoPageResponse.text();

    // captions 데이터 추출
    const captionsMatch = html.match(/"captions":\s*(\{[^}]+playerCaptionsTracklistRenderer[^}]+\})/);

    if (!captionsMatch) {
        // 자막이 없는 경우 - 자동 생성 자막 시도
        const innertubeMatch = html.match(/"captionTracks":\s*(\[[^\]]+\])/);
        if (!innertubeMatch) {
            throw new Error('이 영상에는 자막이 없습니다.');
        }
    }

    // captionTracks 추출
    const captionTracksMatch = html.match(/"captionTracks":\s*(\[[^\]]+\])/);

    if (!captionTracksMatch) {
        throw new Error('자막 트랙을 찾을 수 없습니다.');
    }

    let captionTracks;
    try {
        // JSON 파싱을 위해 이스케이프 문자 처리
        const tracksJson = captionTracksMatch[1]
            .replace(/\\u0026/g, '&')
            .replace(/\\"/g, '"');
        captionTracks = JSON.parse(tracksJson);
    } catch (e) {
        throw new Error('자막 데이터 파싱 실패');
    }

    if (!captionTracks || captionTracks.length === 0) {
        throw new Error('사용 가능한 자막이 없습니다.');
    }

    // 원하는 언어의 자막 찾기, 없으면 첫 번째 자막 사용
    let targetTrack = captionTracks.find(track =>
        track.languageCode === lang || track.vssId?.includes(lang)
    );

    if (!targetTrack) {
        // 한국어 없으면 영어, 없으면 첫 번째
        targetTrack = captionTracks.find(track => track.languageCode === 'en') || captionTracks[0];
    }

    if (!targetTrack?.baseUrl) {
        throw new Error('자막 URL을 찾을 수 없습니다.');
    }

    // 자막 XML 가져오기
    const captionUrl = targetTrack.baseUrl.replace(/\\u0026/g, '&');
    const captionResponse = await fetch(captionUrl);

    if (!captionResponse.ok) {
        throw new Error('자막 데이터를 가져올 수 없습니다.');
    }

    const captionXml = await captionResponse.text();

    // XML에서 자막 텍스트 추출
    const segments = [];
    const textRegex = /<text start="([^"]+)" dur="([^"]+)"[^>]*>([^<]*)<\/text>/g;
    let match;

    while ((match = textRegex.exec(captionXml)) !== null) {
        const start = parseFloat(match[1]);
        const duration = parseFloat(match[2]);
        // HTML 엔티티 디코딩
        const text = match[3]
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/\n/g, ' ')
            .trim();

        if (text) {
            segments.push({ start, duration, text });
        }
    }

    const fullText = segments.map(s => s.text).join(' ');

    return {
        videoId,
        language: targetTrack.languageCode || lang,
        languageName: targetTrack.name?.simpleText || targetTrack.languageCode,
        segments,
        fullText,
        isAutoGenerated: targetTrack.kind === 'asr',
    };
}
