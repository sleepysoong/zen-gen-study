/**
 * YouTube 자막 추출 API
 * CORS 프록시를 사용하여 YouTube Innertube API 호출
 */

// 무료 CORS 프록시 목록 (백업용)
const CORS_PROXIES = [
    '', // 직접 시도 (프록시 없이)
    'https://corsproxy.io/?',
    'https://api.allorigins.win/raw?url=',
];

const INNERTUBE_API_URL = 'https://www.youtube.com/youtubei/v1/player';
const DEFAULT_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';

// ANDROID 클라이언트 사용
const INNERTUBE_CONTEXT = {
    client: {
        clientName: 'ANDROID',
        clientVersion: '19.09.37',
        androidSdkVersion: 30,
        hl: 'ko',
        gl: 'KR',
    }
};

export default async function handler(req, res) {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    const { videoId, lang = 'ko' } = req.query;

    if (!videoId) {
        return res.status(400).json({ error: 'videoId is required' });
    }

    if (!/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
        return res.status(400).json({ error: 'Invalid video ID format' });
    }

    // 여러 프록시 시도
    for (let i = 0; i < CORS_PROXIES.length; i++) {
        try {
            const proxy = CORS_PROXIES[i];
            console.log(`[Attempt ${i + 1}] Using proxy: ${proxy || 'direct'}`);

            const transcript = await fetchTranscript(videoId, lang, proxy);
            return res.status(200).json(transcript);
        } catch (error) {
            console.error(`[Attempt ${i + 1}] Failed:`, error.message);
            // 다음 프록시 시도
        }
    }

    return res.status(500).json({
        error: '자막을 가져올 수 없습니다. 이 영상에 자막이 없거나 YouTube가 접근을 차단했습니다.',
        videoId,
    });
}

async function fetchTranscript(videoId, preferredLang, proxyPrefix = '') {
    // Innertube API 호출
    const apiUrl = `${INNERTUBE_API_URL}?key=${DEFAULT_API_KEY}`;
    const targetUrl = proxyPrefix ? `${proxyPrefix}${encodeURIComponent(apiUrl)}` : apiUrl;

    const response = await fetch(targetUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            context: INNERTUBE_CONTEXT,
            videoId: videoId,
        }),
    });

    if (!response.ok) {
        throw new Error(`API 요청 실패: ${response.status}`);
    }

    const data = await response.json();

    // Playability 확인
    const status = data.playabilityStatus?.status;
    const reason = data.playabilityStatus?.reason;

    if (status === 'LOGIN_REQUIRED') {
        if (reason && (reason.includes('bot') || reason.includes('Sign in') || reason.includes('봇'))) {
            throw new Error('YouTube가 봇을 감지했습니다.');
        }
        throw new Error(reason || '로그인이 필요합니다.');
    }

    if (status !== 'OK') {
        throw new Error(reason || '영상을 재생할 수 없습니다.');
    }

    // 자막 트랙 확인
    const captionsRenderer = data.captions?.playerCaptionsTracklistRenderer;
    if (!captionsRenderer) {
        throw new Error('이 영상에는 자막이 비활성화되어 있습니다.');
    }

    const captionTracks = captionsRenderer.captionTracks || [];
    if (captionTracks.length === 0) {
        throw new Error('이 영상에는 사용 가능한 자막이 없습니다.');
    }

    // 자막 트랙 선택
    const targetTrack = selectTrack(captionTracks, preferredLang);

    // 자막 데이터 가져오기 (JSON3 형식)
    let transcriptUrl = targetTrack.baseUrl;
    transcriptUrl = transcriptUrl.replace('&fmt=srv3', '&fmt=json3');
    if (!transcriptUrl.includes('fmt=')) {
        transcriptUrl += '&fmt=json3';
    }

    // 자막 URL도 프록시 사용
    const transcriptTargetUrl = proxyPrefix
        ? `${proxyPrefix}${encodeURIComponent(transcriptUrl)}`
        : transcriptUrl;

    const transcriptResponse = await fetch(transcriptTargetUrl);

    if (!transcriptResponse.ok) {
        throw new Error('자막 데이터를 가져올 수 없습니다.');
    }

    const transcriptText = await transcriptResponse.text();

    // 파싱
    let segments;
    try {
        const json = JSON.parse(transcriptText);
        segments = parseJson3(json);
    } catch {
        segments = parseSrv3Xml(transcriptText);
    }

    if (segments.length === 0) {
        throw new Error('자막 내용을 파싱할 수 없습니다.');
    }

    const fullText = segments.map(s => s.text).join(' ');

    // 언어 이름 추출
    let languageName = targetTrack.languageCode;
    if (targetTrack.name?.runs?.[0]) {
        languageName = targetTrack.name.runs[0].text;
    } else if (targetTrack.name?.simpleText) {
        languageName = targetTrack.name.simpleText;
    }

    return {
        videoId,
        language: targetTrack.languageCode || preferredLang,
        languageName,
        segments,
        fullText,
        segmentCount: segments.length,
        isAutoGenerated: targetTrack.kind === 'asr',
    };
}

function selectTrack(tracks, preferredLang) {
    const manualTracks = tracks.filter(t => t.kind !== 'asr');
    const generatedTracks = tracks.filter(t => t.kind === 'asr');

    const findTrack = (list, lang) => list.find(t => t.languageCode === lang);

    let target = findTrack(manualTracks, preferredLang);
    if (!target) target = findTrack(generatedTracks, preferredLang);
    if (!target) target = findTrack(manualTracks, 'ko');
    if (!target) target = findTrack(generatedTracks, 'ko');
    if (!target) target = findTrack(manualTracks, 'en');
    if (!target) target = findTrack(generatedTracks, 'en');
    if (!target) target = tracks[0];

    if (!target || !target.baseUrl) {
        throw new Error('자막 URL을 찾을 수 없습니다.');
    }

    return target;
}

function parseJson3(json) {
    const segments = [];

    if (!json.events) return segments;

    for (const event of json.events) {
        if (event.segs) {
            const text = event.segs.map(s => s.utf8 || '').join('').trim();
            if (text) {
                segments.push({
                    start: (event.tStartMs || 0) / 1000,
                    duration: (event.dDurationMs || 0) / 1000,
                    text,
                });
            }
        }
    }

    return segments;
}

function parseSrv3Xml(xmlText) {
    const segments = [];

    const pTagRegex = /<p\s+t="(\d+)"(?:\s+d="(\d+)")?[^>]*>([\s\S]*?)<\/p>/g;
    let match;

    while ((match = pTagRegex.exec(xmlText)) !== null) {
        const startMs = parseInt(match[1]);
        const durationMs = parseInt(match[2] || '0');
        const content = match[3];

        let text = '';
        const sTagRegex = /<s[^>]*>([^<]*)<\/s>/g;
        let sMatch;
        while ((sMatch = sTagRegex.exec(content)) !== null) {
            text += sMatch[1];
        }

        if (!text) {
            text = content.replace(/<[^>]*>/g, '');
        }

        text = decodeHtmlEntities(text.trim());
        if (text) {
            segments.push({
                start: startMs / 1000,
                duration: durationMs / 1000,
                text,
            });
        }
    }

    if (segments.length === 0) {
        const textRegex = /<text\s+start="([^"]+)"(?:\s+dur="([^"]+)")?[^>]*>([\s\S]*?)<\/text>/g;
        while ((match = textRegex.exec(xmlText)) !== null) {
            const start = parseFloat(match[1]);
            const duration = parseFloat(match[2] || '0');
            let text = match[3].replace(/<[^>]*>/g, '');
            text = decodeHtmlEntities(text.trim());
            if (text) {
                segments.push({ start, duration, text });
            }
        }
    }

    return segments;
}

function decodeHtmlEntities(text) {
    if (!text) return '';

    return text
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&apos;/g, "'")
        .replace(/&#(\d+);/g, (_, num) => String.fromCharCode(parseInt(num, 10)))
        .replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
        .replace(/\n/g, ' ');
}
