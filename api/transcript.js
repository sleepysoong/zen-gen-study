/**
 * YouTube 자막 추출 API
 * youtube-transcript-api 라이브러리 방식을 참고하여 구현
 * Innertube API 사용
 */

// Innertube API 설정
const WATCH_URL = 'https://www.youtube.com/watch?v=';
const INNERTUBE_API_URL = 'https://www.youtube.com/youtubei/v1/player?key=';
const INNERTUBE_CONTEXT = {
    client: {
        clientName: 'WEB',
        clientVersion: '2.20240101.00.00',
        hl: 'ko',
        gl: 'KR',
    }
};

export default async function handler(req, res) {
    // CORS 헤더 설정
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    const { videoId, lang = 'ko' } = req.query;

    if (!videoId) {
        return res.status(400).json({ error: 'videoId is required' });
    }

    // videoId 유효성 검사
    if (!/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
        return res.status(400).json({ error: 'Invalid video ID format' });
    }

    try {
        const transcript = await fetchTranscript(videoId, lang);
        return res.status(200).json(transcript);
    } catch (error) {
        console.error('Transcript fetch error:', error.message);
        return res.status(500).json({
            error: error.message || '자막을 가져올 수 없습니다.',
            videoId,
        });
    }
}

async function fetchTranscript(videoId, preferredLang) {
    // 1. YouTube 페이지에서 API 키 추출
    const html = await fetchVideoHtml(videoId);
    const apiKey = extractInnertubeApiKey(html, videoId);

    // 2. Innertube API로 자막 정보 가져오기
    const innertubeData = await fetchInnertubeData(videoId, apiKey);
    const captionsJson = extractCaptionsJson(innertubeData, videoId);

    // 3. 자막 트랙 찾기
    const captionTracks = captionsJson.captionTracks || [];

    if (captionTracks.length === 0) {
        throw new Error('이 영상에는 자막이 없습니다.');
    }

    // 우선순위: 선호 언어 > 한국어 > 영어 > 첫 번째
    let targetTrack = findTrack(captionTracks, preferredLang);
    if (!targetTrack) targetTrack = findTrack(captionTracks, 'ko');
    if (!targetTrack) targetTrack = findTrack(captionTracks, 'en');
    if (!targetTrack) targetTrack = captionTracks[0];

    if (!targetTrack || !targetTrack.baseUrl) {
        throw new Error('자막 URL을 찾을 수 없습니다.');
    }

    // 4. 자막 데이터 가져오기
    const transcriptUrl = targetTrack.baseUrl.replace('&fmt=srv3', '');
    const transcriptResponse = await fetch(transcriptUrl);

    if (!transcriptResponse.ok) {
        throw new Error('자막 데이터를 가져올 수 없습니다.');
    }

    const transcriptXml = await transcriptResponse.text();
    const segments = parseTranscriptXml(transcriptXml);

    if (segments.length === 0) {
        throw new Error('자막 내용을 파싱할 수 없습니다.');
    }

    const fullText = segments.map(s => s.text).join(' ');
    const languageName = targetTrack.name?.runs?.[0]?.text ||
        targetTrack.name?.simpleText ||
        targetTrack.languageCode;

    return {
        videoId,
        language: targetTrack.languageCode || preferredLang,
        languageName,
        segments,
        fullText,
        segmentCount: segments.length,
        isAutoGenerated: targetTrack.kind === 'asr',
    };
}

function findTrack(tracks, langCode) {
    return tracks.find(t => t.languageCode === langCode);
}

async function fetchVideoHtml(videoId) {
    const response = await fetch(WATCH_URL + videoId, {
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
        },
    });

    if (!response.ok) {
        throw new Error('YouTube 페이지를 가져올 수 없습니다.');
    }

    return await response.text();
}

function extractInnertubeApiKey(html, videoId) {
    const pattern = /"INNERTUBE_API_KEY":\s*"([a-zA-Z0-9_-]+)"/;
    const match = html.match(pattern);

    if (match && match[1]) {
        return match[1];
    }

    // 대체 패턴
    const altPattern = /"innertubeApiKey":\s*"([a-zA-Z0-9_-]+)"/;
    const altMatch = html.match(altPattern);

    if (altMatch && altMatch[1]) {
        return altMatch[1];
    }

    // 기본 API 키 (공개된 웹 클라이언트 키)
    return 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';
}

async function fetchInnertubeData(videoId, apiKey) {
    const response = await fetch(INNERTUBE_API_URL + apiKey, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        },
        body: JSON.stringify({
            context: INNERTUBE_CONTEXT,
            videoId: videoId,
        }),
    });

    if (!response.ok) {
        throw new Error('Innertube API 요청 실패');
    }

    return await response.json();
}

function extractCaptionsJson(innertubeData, videoId) {
    // Playability 확인
    const playabilityStatus = innertubeData.playabilityStatus;
    if (playabilityStatus) {
        const status = playabilityStatus.status;
        if (status !== 'OK' && status) {
            const reason = playabilityStatus.reason || '영상을 재생할 수 없습니다.';
            throw new Error(reason);
        }
    }

    const captions = innertubeData.captions;
    if (!captions) {
        throw new Error('자막 정보가 없습니다.');
    }

    const captionsJson = captions.playerCaptionsTracklistRenderer;
    if (!captionsJson || !captionsJson.captionTracks) {
        throw new Error('이 영상에는 자막이 없습니다.');
    }

    return captionsJson;
}

function parseTranscriptXml(xmlText) {
    const segments = [];

    // XML 파싱을 위한 정규식
    const textRegex = /<text start="([^"]+)"(?: dur="([^"]+)")?[^>]*>([^<]*)<\/text>/g;
    let match;

    while ((match = textRegex.exec(xmlText)) !== null) {
        const start = parseFloat(match[1]);
        const duration = parseFloat(match[2] || '0');
        const text = decodeHtmlEntities(match[3]).trim();

        if (text) {
            segments.push({ start, duration, text });
        }
    }

    // 대체 파싱 (태그가 다른 경우)
    if (segments.length === 0) {
        const altRegex = /<p t="(\d+)" d="(\d+)"[^>]*>([^<]*)<\/p>/g;
        while ((match = altRegex.exec(xmlText)) !== null) {
            const start = parseInt(match[1]) / 1000;
            const duration = parseInt(match[2]) / 1000;
            const text = decodeHtmlEntities(match[3]).trim();

            if (text) {
                segments.push({ start, duration, text });
            }
        }
    }

    return segments;
}

function decodeHtmlEntities(text) {
    if (!text) return '';

    return text
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&apos;/g, "'")
        .replace(/&#(\d+);/g, (_, num) => String.fromCharCode(parseInt(num, 10)))
        .replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
        .replace(/\n/g, ' ')
        .replace(/<[^>]*>/g, ''); // HTML 태그 제거
}
